diff --git a/dist/utils/json-parse.js b/dist/utils/json-parse.js
index 643511d0c33848c983167a79b318fc2836270ebd..8a064f2df8971ef235aa2226c0ad7f6553bbd398 100644
--- a/dist/utils/json-parse.js
+++ b/dist/utils/json-parse.js
@@ -1,4 +1,95 @@
 import { parse as partialParse } from "partial-json";
+
+// ── Unsafe integer preservation (matches ollama-stream.ts logic) ────────────
+const MAX_SAFE_INTEGER_ABS_STR = String(Number.MAX_SAFE_INTEGER);
+
+function isAsciiDigit(ch) {
+    return ch !== undefined && ch >= "0" && ch <= "9";
+}
+
+function parseJsonNumberToken(input, start) {
+    let idx = start;
+    if (input[idx] === "-") idx += 1;
+    if (idx >= input.length) return null;
+    if (input[idx] === "0") {
+        idx += 1;
+    } else if (isAsciiDigit(input[idx]) && input[idx] !== "0") {
+        while (isAsciiDigit(input[idx])) idx += 1;
+    } else {
+        return null;
+    }
+    let isInteger = true;
+    if (input[idx] === ".") {
+        isInteger = false;
+        idx += 1;
+        if (!isAsciiDigit(input[idx])) return null;
+        while (isAsciiDigit(input[idx])) idx += 1;
+    }
+    if (input[idx] === "e" || input[idx] === "E") {
+        isInteger = false;
+        idx += 1;
+        if (input[idx] === "+" || input[idx] === "-") idx += 1;
+        if (!isAsciiDigit(input[idx])) return null;
+        while (isAsciiDigit(input[idx])) idx += 1;
+    }
+    return { token: input.slice(start, idx), end: idx, isInteger };
+}
+
+function isUnsafeIntegerLiteral(token) {
+    const digits = token[0] === "-" ? token.slice(1) : token;
+    if (digits.length < MAX_SAFE_INTEGER_ABS_STR.length) return false;
+    if (digits.length > MAX_SAFE_INTEGER_ABS_STR.length) return true;
+    return digits > MAX_SAFE_INTEGER_ABS_STR;
+}
+
+function quoteUnsafeIntegerLiterals(input) {
+    let out = "";
+    let inString = false;
+    let escaped = false;
+    let idx = 0;
+    while (idx < input.length) {
+        const ch = input[idx] ?? "";
+        if (inString) {
+            out += ch;
+            if (escaped) {
+                escaped = false;
+            } else if (ch === "\\") {
+                escaped = true;
+            } else if (ch === '"') {
+                inString = false;
+            }
+            idx += 1;
+            continue;
+        }
+        if (ch === '"') {
+            inString = true;
+            out += ch;
+            idx += 1;
+            continue;
+        }
+        if (ch === "-" || isAsciiDigit(ch)) {
+            const parsed = parseJsonNumberToken(input, idx);
+            if (parsed) {
+                if (parsed.isInteger && isUnsafeIntegerLiteral(parsed.token)) {
+                    out += `"${parsed.token}"`;
+                } else {
+                    out += parsed.token;
+                }
+                idx = parsed.end;
+                continue;
+            }
+        }
+        out += ch;
+        idx += 1;
+    }
+    return out;
+}
+
+function safeJsonParse(json) {
+    return JSON.parse(quoteUnsafeIntegerLiterals(json));
+}
+// ── End unsafe integer preservation ─────────────────────────────────────────
+
 /**
  * Attempts to parse potentially incomplete JSON during streaming.
  * Always returns a valid object, even if the JSON is incomplete.
@@ -12,7 +103,7 @@ export function parseStreamingJson(partialJson) {
     }
     // Try standard parsing first (fastest for complete JSON)
     try {
-        return JSON.parse(partialJson);
+        return safeJsonParse(partialJson);
     }
     catch {
         // Try partial-json for incomplete JSON
